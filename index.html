<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>

  <style>
    @import "tailwindcss";

    #matter-container  {
      border: 1px solid #231f20;
      height: 100vh;
      width: 100vw; 
    }
  </style>
</head>
<body >


<svg id="Layer_1" style="display: none;" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 101.15">
  <defs>
    <style>
      .cls-1 {
        fill: #231f20;
      }
    </style>
  </defs>
  <path id="matter-path" class="cls-1" d="M61.04,71.28H28.43l-7.22,20.49,10.82,1.15v8.23H0v-8.23l9.52-1.15L44.59,0h11.26l33.77,91.77,10.39,1.15v8.23h-43.43v-8.23l11.26-1.15-6.78-20.49ZM31.46,61.76h26.84l-12.55-36.36h-.43l-13.85,36.36Z"/>
</svg>


<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 86.31">
  <defs>
    <style>
      .cls-1 {
        fill: #231f20;
      }
    </style>
  </defs>
  <path id="matter-path" class="cls-1" d="M100,0v7.03l-8.51.74v70.53l8.51.86v7.15h-33.17v-7.15l9.25-.86V10.97h-.49l-24.17,75.34h-9.49L16.89,11.1h-.49v67.2l8.51.86v7.15H0v-7.15l7.64-.86V7.77l-7.64-.74V0h30.46l19.85,62.27h.49L70.65,0h29.35Z"/>
</svg>


  <div id="matter-container" class="w-full h-full">
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/4.0.0-alpha.12/lib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pathseg@1.2.1/pathseg.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <script>
    const THICCNESS = 60;
    const SVG_PATH_SELECTOR = "#matter-path";
    const SVG_WIDTH_IN_PX = 100;
    const SVG_WIDTH_AS_PERCENT_OF_CONTAINER_WIDTH = 0.3;

    const matterContainer = document.querySelector("#matter-container");

    // module aliases
    var Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Bodies = Matter.Bodies,
      Composite = Matter.Composite,
      Body = Matter.Body,
      Svg = Matter.Svg,
      Vector = Matter.Vector,
      Vertices = Matter.Vertices;

    // create an engine
    var engine = Engine.create();

    // create a renderer
    var render = Render.create({
      element: matterContainer,
      engine: engine,
      options: {
        width: matterContainer.clientWidth,
        height: matterContainer.clientHeight,
        background: "transparent",
        wireframes: false,
        showAngleIndicator: false
      }
    });

    createCircle();
    createSvgBodies();

    var ground = Bodies.rectangle(
      matterContainer.clientWidth / 2,
      matterContainer.clientHeight + THICCNESS / 2,
      27184,
      THICCNESS,
      { isStatic: true }
    );

    let leftWall = Bodies.rectangle(
      0 - THICCNESS / 2,
      matterContainer.clientHeight / 2,
      THICCNESS,
      matterContainer.clientHeight * 5,
      {
        isStatic: true
      }
    );

    let rightWall = Bodies.rectangle(
      matterContainer.clientWidth + THICCNESS / 2,
      matterContainer.clientHeight / 2,
      THICCNESS,
      matterContainer.clientHeight * 5,
      { isStatic: true }
    );

    // add all of the bodies to the world
    Composite.add(engine.world, [ground, leftWall, rightWall]);

    let mouse = Matter.Mouse.create(render.canvas);
    let mouseConstraint = Matter.MouseConstraint.create(engine, {
      mouse: mouse,
      constraint: {
        stiffness: 0.2,
        render: {
          visible: false
        }
      }
    });

    Composite.add(engine.world, mouseConstraint);

    // allow scroll through the canvas
    mouseConstraint.mouse.element.removeEventListener(
      "mousewheel",
      mouseConstraint.mouse.mousewheel
    );
    mouseConstraint.mouse.element.removeEventListener(
      "DOMMouseScroll",
      mouseConstraint.mouse.mousewheel
    );

    // run the renderer
    Render.run(render);

    // create runner
    var runner = Runner.create();

    // run the engine
    Runner.run(runner, engine);
    console.log(Composite.allBodies(engine.world));

    function createCircle() {
      let circleDiameter =
        matterContainer.clientWidth * SVG_WIDTH_AS_PERCENT_OF_CONTAINER_WIDTH;
      let circle = Bodies.circle(
        matterContainer.clientWidth / 2,
        10,
        circleDiameter / 2,
        {
          friction: 0.3,
          frictionAir: 0.00001,
          restitution: 0.8,
          render: {
            fillStyle: "#ECA869",
            strokeStyle: "#ECA869"
          }
        }
      );
      Composite.add(engine.world, circle);
    }

    function createSvgBodies() {
      const paths = document.querySelectorAll(SVG_PATH_SELECTOR);
      paths.forEach((path, index) => {
        let vertices = Svg.pathToVertices(path);
        let scaleFactor =
          (matterContainer.clientWidth * SVG_WIDTH_AS_PERCENT_OF_CONTAINER_WIDTH) /
          SVG_WIDTH_IN_PX;
        vertices = Vertices.scale(vertices, scaleFactor, scaleFactor);
        let svgBody = Bodies.fromVertices(
          index * SVG_WIDTH_IN_PX + 200,
          0,
          [vertices],
          {
            friction: 0.3,
            frictionAir: 0.00001,
            restitution: 0.8,
            render: {
              fillStyle: "#464655",
              strokeStyle: "#464655",
              lineWidth: 1
            }
          }
        );
        Composite.add(engine.world, svgBody);
      });
    }

    function scaleBodies() {
      const allBodies = Composite.allBodies(engine.world);

      allBodies.forEach((body) => {
        if (body.isStatic === true) return; // don't scale walls and ground
        const { min, max } = body.bounds;
        const bodyWidth = max.x - min.x;
        let scaleFactor =
          (matterContainer.clientWidth * SVG_WIDTH_AS_PERCENT_OF_CONTAINER_WIDTH) /
          bodyWidth;

        Body.scale(body, scaleFactor, scaleFactor);
      });
    }

    function handleResize(matterContainer) {
      // set canvas size to new values
      render.canvas.width = matterContainer.clientWidth;
      render.canvas.height = matterContainer.clientHeight;

      // reposition ground
      Body.setPosition(
        ground,
        Vector.create(
          matterContainer.clientWidth / 2,
          matterContainer.clientHeight + THICCNESS / 2
        )
      );

      // reposition right wall
      Body.setPosition(
        rightWall,
        Vector.create(
          matterContainer.clientWidth + THICCNESS / 2,
          matterContainer.clientHeight / 2
        )
      );

      scaleBodies();
    }

    window.addEventListener("resize", () => handleResize(matterContainer));
  </script>
</body>
</html>
